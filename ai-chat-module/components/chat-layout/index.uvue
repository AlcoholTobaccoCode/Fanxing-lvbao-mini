<!--
@description: 统一的聊天页面布局组件
@usage: 用于咨询、法规、案例等所有聊天详情页
-->
<script lang="ts" setup>
import { ref, nextTick, watch, onMounted, getCurrentInstance } from "vue";

const props = defineProps<{
	// 是否正在生成中
	loading?: boolean;
	// 状态文案
	statusText?: string;
	// 是否显示空状态
	showEmpty?: boolean;
	// 空状态文案
	emptyText?: string;
	// 键盘高度
	keyboardHeight?: number;
}>();

// 滚动控制
const scrollTop = ref(0);
// 用户是否主动上滑（核心状态）
const isUserScrolledUp = ref(false);
// scroll-view 可视区域高度
const scrollViewHeight = ref(0);
// 是否已完成初始化（保护期内不判断位置）
const isInitialized = ref(false);
// 用户是否正在触摸滚动区域
const isTouching = ref(false);

// 获取 scroll-view 高度
const instance = getCurrentInstance();
const updateScrollViewHeight = () => {
	uni.createSelectorQuery()
		.in(instance)
		.select(".chat-layout__scroll")
		.boundingClientRect((rect: any) => {
			if (rect && rect.height > 0) {
				scrollViewHeight.value = rect.height;
			}
		})
		.exec();
};

onMounted(() => {
	// 立即尝试获取高度
	updateScrollViewHeight();
	// 延迟再获取一次，确保渲染完成
	setTimeout(() => {
		updateScrollViewHeight();
		// 初始化完成后，延迟开启位置判断（给自动滚动留时间）
		setTimeout(() => {
			isInitialized.value = true;
		}, 300);
	}, 100);
});

// 判断是否在底部附近
const isNearBottom = (scrollTop: number, scrollHeight: number): boolean => {
	const distanceToBottom = scrollHeight - scrollTop - scrollViewHeight.value;
	// 使用固定像素(50px)和百分比(5%)的较大值作为容差
	// const tolerance = Math.max(50, scrollViewHeight.value * 0.05);
	// return distanceToBottom < tolerance;
	return distanceToBottom < scrollViewHeight.value * 0.03;
};

// 滚动到底部
const scrollToBottom = () => {
	// 用户上滑或正在触摸时，不自动滚动
	if (isUserScrolledUp.value || isTouching.value) return;
	nextTick(() => {
		scrollTop.value = scrollTop.value === 99999 ? 99998 : 99999;
	});
};

// 处理滚动事件
const handleScroll = (e: any) => {
	if (!isInitialized.value) return;
	if (scrollViewHeight.value <= 0) return;

	const currentScrollTop = e.detail?.scrollTop ?? 0;
	const scrollHeight = e.detail?.scrollHeight ?? 0;
	const atBottom = isNearBottom(currentScrollTop, scrollHeight);

	// 滚到底部时重置状态，恢复自动滚动
	if (atBottom) {
		isUserScrolledUp.value = false;
	}
};

// 重置自动滚动（开启新一轮对话时调用）
const resetAutoScroll = () => {
	isUserScrolledUp.value = false;
	nextTick(() => {
		scrollTop.value = scrollTop.value === 99999 ? 99998 : 99999;
	});
};

// 触摸开始 - 立即中断自动滚动
const handleTouchStart = () => {
	isTouching.value = true;
	isUserScrolledUp.value = true; // 立即设置，确保第一次滑动就能响应
};

// 触摸结束
const handleTouchEnd = () => {
	// 延迟重置，给惯性滚动留出时间
	setTimeout(() => {
		isTouching.value = false;
	}, 300);
};

// 暴露方法给父组件
defineExpose({
	scrollToBottom,
	resetAutoScroll
});

// 监听 loading 状态
watch(
	() => props.loading,
	(val) => {
		if (val) {
			nextTick(() => {
				scrollToBottom();
			});
		}
	}
);
</script>

<template>
	<view class="chat-layout">
		<!-- <view
			style="
				position: fixed;
				top: 200px;
				left: 0;
				z-index: 200;
				background-color: rgba(0, 0, 0, 1);
			"
			class="flex flex-col gap-2 p-4"
		>
			<cl-text color="#2da042"> scrollTop:{{ scrollTop }} </cl-text>
			<cl-text color="#2da042"> isUserScrolledUp:{{ isUserScrolledUp }} </cl-text>
			<cl-text color="#2da042"> scrollViewHeight:{{ scrollViewHeight }} </cl-text>
			<cl-text color="#2da042"> isTouching:{{ isTouching }} </cl-text>
		</view> -->

		<!-- 空状态 -->
		<view v-if="showEmpty" class="chat-layout__empty">
			<text class="empty-text">{{ emptyText || "暂无内容" }}</text>
		</view>

		<!-- 聊天区域 -->
		<view v-else class="chat-layout__scroll-wrapper">
			<scroll-view
				scroll-y
				class="chat-layout__scroll"
				:enable-flex="true"
				:scroll-top="scrollTop"
				:scroll-with-animation="true"
				@scroll="handleScroll"
				@touchstart="handleTouchStart"
				@touchend="handleTouchEnd"
			>
				<!-- 消息列表插槽 -->
				<slot name="messages"></slot>

				<!-- 加载状态 -->
				<view v-if="loading && statusText" class="chat-layout__status">
					<view class="status-row">
						<view class="status-spinner"></view>
						<text class="status-text">{{ statusText }}</text>
					</view>
					<view class="status-dots">
						<view class="status-dot status-dot--1"></view>
						<view class="status-dot status-dot--2"></view>
						<view class="status-dot status-dot--3"></view>
					</view>
				</view>
			</scroll-view>
		</view>

		<!-- 输入框容器 - 使用 paddingBottom 补偿键盘高度 -->
		<view
			class="chat-layout__input-wrapper"
			:style="{
				paddingBottom: (keyboardHeight ?? 0) > 0 ? (keyboardHeight ?? 0) + 'px' : ''
			}"
		>
			<slot name="input"></slot>
		</view>
	</view>
</template>

<style lang="scss" scoped>
.chat-layout {
	@apply w-full h-full flex flex-col;
	background-color: #fafafa;
	overflow: hidden;
}

.chat-layout__empty {
	@apply flex-1 flex items-center justify-center px-4 py-6;
}

.empty-text {
	@apply text-sm text-center;
	color: #9ca3af;
}

.chat-layout__scroll-wrapper {
	@apply flex-1 px-2 pt-2 pb-2;
	min-height: 0; /* 关键：允许 flex 子项收缩 */
	overflow: hidden;
}

.chat-layout__scroll {
	@apply w-full h-full;
}

.chat-layout__input-wrapper {
	padding-bottom: 20px;
	padding-bottom: calc(20px + constant(safe-area-inset-bottom));
	padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
	background-color: #fafafa;
}

// 状态显示
.chat-layout__status {
	@apply px-4 py-3;
}

.status-row {
	@apply flex flex-row items-center mb-1;
}

.status-spinner {
	width: 14px;
	height: 14px;
	border-radius: 999px;
	border-width: 2px;
	border-style: solid;
	border-color: #e5e7eb;
	border-top-color: #296d9d; // 主题色
	animation: status-spin 1s linear infinite;
}

.status-text {
	@apply text-sm ml-2;
	color: #296d9d; // 主题色
}

.status-dots {
	@apply flex flex-row items-center mt-1;
}

.status-dot {
	width: 6px;
	height: 6px;
	border-radius: 999px;
	background-color: #296d9d; // 主题色
	margin-right: 4px;
	animation: status-blink 1.4s infinite both;
}

.status-dot--2 {
	animation-delay: 0.2s;
}

.status-dot--3 {
	animation-delay: 0.4s;
}

@keyframes status-spin {
	0% {
		transform: rotate(0deg);
	}
	100% {
		transform: rotate(360deg);
	}
}

@keyframes status-blink {
	0%,
	80%,
	100% {
		opacity: 0.2;
	}
	40% {
		opacity: 1;
	}
}
</style>
