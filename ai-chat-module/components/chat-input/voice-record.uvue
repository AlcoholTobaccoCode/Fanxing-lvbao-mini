<script lang="ts" setup>
import { ref, computed, watch, getCurrentInstance, onMounted, nextTick } from "vue";
import type { VoiceResult } from "@/cool/types/chat-input";
import { useUi } from "@/uni_modules/cool-ui";

import Recorder from "recorder-core";
import RecordApp from "recorder-core/src/app-support/app";
import "@/uni_modules/Recorder-UniCore/app-uni-support.js";
// #ifdef MP-WEIXIN
import "recorder-core/src/app-support/app-miniProgram-wx-support.js";
// #endif
import "recorder-core/src/engine/mp3";
import "recorder-core/src/engine/mp3-engine";
// #ifdef H5 || MP-WEIXIN
import "recorder-core/src/extensions/waveview.js";
import "recorder-core/src/extensions/frequency.histogram.view.js";
import "recorder-core/src/extensions/lib.fft.js";
// #endif

const props = defineProps({
	// 波形类型：WaveView 或 Histogram3
	waveType: {
		type: String,
		default: () => "Histogram3"
	}
});

const emit = defineEmits<{
	(e: "finish", value: VoiceResult): void;
}>();

const ui = useUi();

const isShowModal = defineModel("isShow", {
	type: Boolean,
	default: () => false
});

/**
 * 录音状态
 * recording -> 录音中
 * cancel -> 取消
 * translate -> 转文字
 */
const status = ref<"recording" | "cancel" | "translate">("recording");

/** 起始触摸 Y 坐标 */
const startTouchY = ref(0);
/** 当前触摸 Y 坐标 */
const currentTouchY = ref(0);
/** 上划取消阈值（px） */
const CANCEL_THRESHOLD = 80;

/** 是否处于取消区域 */
const isInCancelArea = computed(() => {
	return startTouchY.value - currentTouchY.value > CANCEL_THRESHOLD;
});

/** 底部提示文字 */
const bottomTipText = computed(() => {
	if (status.value === "cancel") return "松开取消";
	return "松开发送";
});

const tipText = computed(() => {
	if (status.value === "cancel") return "松开 手指，取消发送";
	if (status.value === "translate") return "松开 手指，转为文字";
	return "松开 发送";
});

const subText = computed(() => {
	if (status.value === "cancel") return "松开即可取消";
	if (status.value === "translate") return "松开即可转为文字";
	return "上滑取消";
});

//#region 声波动画相关

// 频谱波形类型
const instance = getCurrentInstance();
const pageCtx = instance?.proxy as any;

const waveConfig = ref({
	width: 80,
	height: 28
});

const waveType = computed<"WaveView" | "Histogram3">(() =>
	props.waveType === "WaveView" ? "WaveView" : "Histogram3"
);

// Recorder 频谱视图实例
const waveStore = ref<any | null>(null);

// 录音状态和权限
const recording = ref(false);
const hasRecordPermission = ref(false);

// 初始化 Recorder 频谱视图（WaveView / Histogram3）
const initWaveStore = () => {
	if (!pageCtx) return;
	if (!waveStore.value) waveStore.value = {};
	const store = waveStore.value as any;

	// WaveView
	if (!store.WaveView) {
		RecordApp.UniFindCanvas(pageCtx, [".recwave-WaveView"], "", (canvas1: any) => {
			if (!canvas1 || !(Recorder as any).WaveView) return;
			store.WaveView = (Recorder as any).WaveView({
				compatibleCanvas: canvas1,
				width: waveConfig.value.width / 2,
				height: waveConfig.value.height / 2
			});
		});
	}

	// Histogram3
	if (!store.Histogram3) {
		RecordApp.UniFindCanvas(pageCtx, [".recwave-Histogram3"], "", (canvas1: any) => {
			if (!canvas1 || !(Recorder as any).FrequencyHistogramView) return;
			store.Histogram3 = (Recorder as any).FrequencyHistogramView({
				compatibleCanvas: canvas1,
				width: waveConfig.value.width / 2,
				height: waveConfig.value.height / 2,
				position: 0,
				minHeight: 1,
				lineCount: 12,
				widthRatio: 0.2,
				fallDuration: 1000,
				stripeFallDuration: 2500,
				stripeEnable: false,
				mirrorEnable: true,
				linear: [0, "#fff", 1, "#fff"]
			});
		});
	}
};
// 请求权限
const ensureRecordPermission = () =>
	new Promise<{ needGetPermission: boolean }>((resolve) => {
		if (hasRecordPermission.value) {
			resolve({
				needGetPermission: false
			});
			return;
		}
		RecordApp.RequestPermission(
			() => {
				hasRecordPermission.value = true;
				resolve({
					needGetPermission: true
				});
			},
			(msg: string, _isUserNotAllow: boolean) => {
				hasRecordPermission.value = false;
				resolve({
					needGetPermission: true
				});
			}
		);
	});

// 开始录音（同时驱动 Recorder 波形绘制）
const startRecordInner = async () => {
	// 防止重复 Start
	if (recording.value) {
		console.warn("[voice-record] 已在录音中，跳过重复 Start");
		return;
	}

	console.info("startRecordInner ============> ");
	try {
		RecordApp.Start(
			{
				type: "mp3",
				sampleRate: 16000,
				bitRate: 16,
				onProcess(buffers: any, powerLevel: number, _duration: number, sampleRate: number) {
					console.info("startRecordInner powerLevel ===> ", powerLevel);
					const store = waveStore.value as any;
					const buf = buffers && buffers.length ? buffers[buffers.length - 1] : null;
					if (!store || !buf) return;
					const key = waveType.value;
					if (key === "WaveView" && store.WaveView) {
						store.WaveView.input(buf, powerLevel, sampleRate);
					} else if (key === "Histogram3" && store.Histogram3) {
						store.Histogram3.input(buf, powerLevel, sampleRate);
					}
				}
			},
			() => {
				recording.value = true;
				initWaveStore();
			},
			(msg: string) => {
				console.error("开始录音失败", msg);
			}
		);
	} catch (err) {
		console.error("开始录音失败", err);
		isShowModal.value = false;
	}
};

// 停止
const stopRecordInner = (discard: boolean, options?: { translate?: boolean }) => {
	if (!recording.value) return;
	recording.value = false;
	RecordApp.Stop(
		(arrayBuffer: ArrayBuffer, duration: number, mime: string) => {
			if (discard) return;

			RecordApp.UniSaveLocalFile(
				"recorder.mp3",
				arrayBuffer,
				async (savePath) => {
					const result: VoiceResult = {
						buffer: arrayBuffer,
						duration,
						mime,
						translate: !!options?.translate,
						tempFilePath: savePath
					};
					emit("finish", result);
				},
				(errMsg) => {
					console.error(errMsg);
				}
			);
		},
		(msg: string) => {
			console.error("结束录音失败", msg);
		}
	);
};

// 录音浮层开关：驱动动画和录音开始/结束
watch(
	() => isShowModal.value,
	(val) => {
		if (val) {
			startRecordInner();
		} else {
			if (status.value === "cancel") {
				stopRecordInner(true);
			} else if (status.value === "translate") {
				stopRecordInner(false, { translate: true });
			} else {
				stopRecordInner(false);
			}
		}
	}
);
//#endregion

const startFromPress = async (e?: TouchEvent) => {
	status.value = "recording";
	const { needGetPermission } = await ensureRecordPermission();
	// 请求权限时先关闭
	// isShowModal.value = false;
	if (!hasRecordPermission.value) {
		return ui.showToast({
			message: "请设置中打开录音权限"
		});
	}

	nextTick(() => {
		if (!needGetPermission) {
			// 记录起始触摸位置
			if (e && e.touches && e.touches[0]) {
				startTouchY.value = e.touches[0].clientY;
				currentTouchY.value = e.touches[0].clientY;
			}

			isShowModal.value = true;
		}
	});
};

const endFromPress = () => {
	status.value = "recording";
	isShowModal.value = false;
};

const cancelFromPress = () => {
	status.value = "cancel";
	isShowModal.value = false;
};

/** 更新触摸位置（供外部调用） */
const updateTouchPosition = (e: TouchEvent) => {
	if (!isShowModal.value) return;

	const touch = e.touches[0];
	if (touch) {
		currentTouchY.value = touch.clientY;

		// 根据滑动距离更新状态
		if (isInCancelArea.value) {
			status.value = "cancel";
		} else {
			status.value = "recording";
		}
	}
};

/** 结束录音（根据当前状态自动决定发送或取消） */
const finishRecording = () => {
	if (status.value === "cancel") {
		cancelFromPress();
	} else {
		endFromPress();
	}
};

const handleFooterClick = () => {
	cancelFromPress();
};

defineExpose({
	ensureRecordPermission,
	startFromPress,
	endFromPress,
	cancelFromPress,
	updateTouchPosition,
	finishRecording
});
</script>

<template>
	<view v-if="isShowModal" class="voice-record-mask" @contextmenu.prevent @longpress.prevent>
		<view class="voice-record-center">
			<!-- 语音气泡 -->
			<view class="voice-record-bubble" :class="{ 'is-cancel': status === 'cancel' }">
				<view class="voice-record-wave">
					<canvas
						v-show="waveType === 'WaveView'"
						type="2d"
						class="recwave-WaveView h-[28px] w-full"
					></canvas>
					<canvas
						v-show="waveType === 'Histogram3'"
						type="2d"
						class="recwave-Histogram3 h-[28px] w-full"
					></canvas>
				</view>
			</view>

			<view class="voice-record-tip-wrap">
				<text class="voice-record-tip-text" :class="{ 'is-cancel': status === 'cancel' }">
					{{ tipText }}
				</text>
				<text class="voice-record-sub-text">{{ subText }}</text>
			</view>
		</view>

		<!-- 底部操作区 -->
		<view class="voice-record-bottom">
			<view
				class="voice-record-bottom-inner"
				:class="{ 'is-cancel': status === 'cancel' }"
				@click="handleFooterClick"
			>
				<text class="voice-record-bottom-text">{{ bottomTipText }}</text>
			</view>
		</view>
	</view>
</template>

<style scoped lang="scss">
.voice-record-mask {
	@apply fixed inset-0 z-[9999] flex flex-col justify-between items-center;
	background-color: rgba(0, 0, 0, 0.6);
}

.voice-record-center {
	@apply flex flex-col items-center justify-center flex-1 w-full;
	padding-top: 120px;
	padding-bottom: 40px;
	box-sizing: border-box;
}

.voice-record-bubble {
	@apply rounded-[24px] px-16 py-2 flex items-center justify-center shadow-lg mx-6 bg-primary-500;
	min-width: 260px;
	position: relative;
	transition: all 0.2s ease;

	&.is-cancel {
		@apply bg-red-500;
	}
}

.voice-record-wave {
	@apply w-full h-full flex flex-row items-center justify-center py-4;
}

.voice-record-tip-wrap {
	@apply mt-10 flex flex-col items-center;
	color: #ffffff;
}

.voice-record-tip-text {
	font-size: 16px;
	font-weight: 500;
	transition: color 0.2s ease;

	&.is-cancel {
		color: #ff6b6b;
	}
}

.voice-record-sub-text {
	margin-top: 6px;
	font-size: 12px;
	opacity: 0.8;
}

.voice-record-bottom {
	@apply w-full pb-16 px-6 flex flex-row items-center justify-center;
}

.voice-record-bottom-inner {
	@apply px-8 py-4 rounded-full bg-white/20 flex items-center justify-center;
	transition: all 0.2s ease;

	&.is-cancel {
		@apply bg-red-500/80;
	}
}

.voice-record-bottom-text {
	font-size: 14px;
	color: #ffffff;
	font-weight: 500;
}
</style>
