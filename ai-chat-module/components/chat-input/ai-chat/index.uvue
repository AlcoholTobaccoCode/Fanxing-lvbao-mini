<script setup lang="ts">
import { nextTick, ref, watch, computed } from "vue";
import type { PropType } from "vue";
import { isDark } from "@/cool";
import { useUi } from "@/uni_modules/cool-ui";
import { uploadToOss } from "@/utils/aliyun/oss";
import { recognizeOnceFromBuffer } from "@/utils/aliyun/asr";
import type { ToolItem, Tools, ActionItems, SendData, VoiceResult } from "@/cool/types/chat-input";

import SimpleCard from "@/components/card/simple-card.uvue";
import VoiceRecord from "../voice-record.uvue";
import ActionsPopup from "../actions-popup.uvue";
// import RealtimeVoiceInput from "../realtime-voice-input.uvue";

const ui = useUi();

const props = defineProps({
	placeholder: {
		type: String,
		default: () => "在这里输入你的问题或按住说话"
	},
	loading: {
		type: Boolean,
		default: () => false
	},
	disabled: {
		type: Boolean,
		default: () => false
	},
	// 使用的模块，用来分类保存语音 OSS 文件
	useModule: {
		type: String,
		default: () => "ai-chat-voice"
	}, // 顶部工具栏：额外传入的工具项
	tools: {
		type: Array as PropType<Tools>,
		default: () => []
	},
	// 默认工具是否展示：深度思考 / 知识库 / 联网
	showDefaultDeepThink: {
		type: Boolean,
		default: () => true
	},
	showDefaultKnowledge: {
		type: Boolean,
		default: () => true
	},
	showDefaultNetwork: {
		type: Boolean,
		default: () => true
	},
	// 是否显示默认意图标签（tools chips）
	showIntentChips: {
		type: Boolean,
		default: () => true
	}
});

/**
 * inputModeModal
 * @default "text"
 * @description: text -> 文本输入 | voice -> 语音输入
 */
const inputModeModal = defineModel("inputMode", {
	type: String,
	default: () => "text"
});

const modelValueModal = defineModel("modelValue", {
	type: String,
	default: () => ""
});

const emit = defineEmits<{
	(e: "send", value: SendData): void;
	(e: "open-call"): void;
	(e: "input-mode-change", value: string): void;
	// 顶部工具选中变化
	(e: "tool-change", value: Tools): void;
	(e: "tool-toggle", value: ToolItem): void;
}>();

// 顶部意图 chips：默认工具 + 外部传入工具
const createDefaultTools = (): Tools => {
	const list: Tools = [];
	if (props.showDefaultDeepThink) {
		list.push({
			icon: "links-line",
			text: "深度思考",
			enable: false
		});
	}
	if (props.showDefaultNetwork) {
		list.push({
			icon: "fxzh-hulianwang",
			text: "联网搜索",
			enable: false
		});
	}
	if (props.showDefaultKnowledge) {
		list.push({
			icon: "fxzh-zhishiku",
			text: "知识库",
			enable: false
		});
	}
	return list;
};

// 顶部工具列表：
const tools = ref<Tools>(
	props.tools && props.tools.length > 0
		? (props.tools as Tools).map((item) => ({ ...item }))
		: createDefaultTools()
);

// 输入框动态最大高度
const inputMaxHeight = computed(() => {
	const { windowHeight } = uni.getSystemInfoSync();
	// 屏幕高度的 50%，上限 500px，下限 200px
	return `${Math.max(Math.min(windowHeight * 0.5, 500), 200)}px`;
});

//#region 语音录制相关

const voiceRecordRef = ref<any>();
const isShowVoiceRecord = ref<any>(false);

// 输入框聚焦状态
const isFocused = ref(false);

// 按住说话：按下时显示语音浮层并通知开始
const handlePressStart = () => {
	isShowVoiceRecord.value = true;
};

// 松开：关闭浮层并通知结束
const handlePressEnd = () => {
	isShowVoiceRecord.value = false;
};

const handleVoiceRecordFinish = async (result: VoiceResult) => {
	if (!result.tempFilePath) {
		return ui.showToast({ message: "语音丢失，请重试" });
	}
	// 上传 OSS
	const res = await uploadToOss({
		filePath: result.tempFilePath,
		dirPrefix: `${props.useModule}/voice`
	});
	result.onlineUrl = res.url;
	// 录音文件识别
	try {
		uni.showLoading({ title: "识别中..." });
		const text = await recognizeOnceFromBuffer(result.buffer, {
			startParams: {
				format: "mp3",
				sample_rate: 16000
			}
		});
		if (text) {
			result.text = text;
		}
	} catch (err: any) {
		console.error("[chat-input] 语音识别失败", err);
		ui.showToast({ message: err?.message || "语音识别失败，请重试" });
		return; // 识别失败时不再继续发送
	} finally {
		nextTick(() => {
			uni.hideLoading();
		});
	}

	// 如果识别结果为空，提示用户重试
	if (!result.text) {
		ui.showToast({ message: "未能识别语音内容，请重试" });
		return;
	}

	const data: SendData = {
		text: result.text,
		mode: "voice",
		voice: {
			...result
		}
	};
	emit("send", data);
	modelValueModal.value = "";
};

//#endregion

//#region 交互
// 更多功能弹层显隐
const showMoreAction = ref(false);

// 顶部工具点击
const handleToolTap = (item: ToolItem) => {
	const target = tools.value.find((t) => t.text === item.text);
	if (!target) return;

	target.enable = !target.enable;
	target.onClick?.(target);
	emit("tool-toggle", { ...target });
	emit("tool-change", tools.value);
};

// 切换输入模式
const handleRecording = () => {
	inputModeModal.value = inputModeModal.value === "text" ? "voice" : "text";
	emit("input-mode-change", inputModeModal.value);
	// 切换到语音模式时，预请求一次录音权限，减少长按时等待
	if (inputModeModal.value === "voice") {
		voiceRecordRef.value?.ensureRecordPermission?.();
	}
};

// 发送
const handleSend = () => {
	if (props.disabled || props.loading) return;
	const val = modelValueModal.value.trim();

	const data = {
		text: val,
		mode: "text" as const
	};

	if (!val) return;
	emit("send", data);
};

// 确认
const handleConfirm = () => {
	handleSend();
};

// 打开底部工具栏
const handleOpenToolbar = () => {
	showMoreAction.value = true;
};

// 处理工具栏选择
const handleActionSelect = (type: ActionItems) => {
	console.log("工具栏选择:", type);
	// TODO: 处理选择结果（上传、发送等）
};

// 输入框聚焦
const handleFocus = () => {
	isFocused.value = true;
};

// 输入框失焦
const handleBlur = () => {
	// 延迟失焦，避免点击按钮时立即失焦
	setTimeout(() => {
		if (!modelValueModal.value) {
			isFocused.value = false;
		}
	}, 200);
};

//#endregion

// 当外部传入的 tools 或默认展示配置变化时，同步内部列表
watch(
	() => ({
		tools: props.tools,
		deepThink: props.showDefaultDeepThink,
		knowledge: props.showDefaultKnowledge,
		network: props.showDefaultNetwork
	}),
	() => {
		const activeMap = new Map<string, boolean>();
		tools.value.forEach((t) => {
			activeMap.set(t.text, !!t.enable);
		});

		let base: Tools;
		if (props.tools && props.tools.length > 0) {
			base = (props.tools as Tools).map((item) => ({ ...item }));
		} else {
			base = [...createDefaultTools(), ...(props.tools || []).map((item) => ({ ...item }))];
		}

		const next: Tools = base.map((item) => ({
			...item,
			enable: activeMap.get(item.text) ?? item.enable ?? false
		}));

		tools.value = next;
	},
	{ deep: true }
);
</script>

<template>
	<simple-card class="chat-input-wrapper" :class="{ 'is-dark': isDark }">
		<!-- 顶部工具区域 -->
		<view class="chat-tools-area">
			<!-- 前置插槽：模型选择等自定义工具 -->
			<slot name="tools-prepend"></slot>

			<!-- 默认意图标签 -->
			<view v-if="showIntentChips && tools.length > 0" class="chat-intent-row">
				<scroll-view scroll-x class="w-full" show-scrollbar="false">
					<view class="chat-intent-row__inner">
						<view
							v-for="(item, idx) in tools"
							:key="item.text + '-' + idx"
							class="chat-intent-chip"
							:class="{ 'chat-intent-chip--active': item.enable }"
							@tap.stop="handleToolTap(item)"
						>
							<cl-icon
								:name="item.icon"
								color="currentColor"
								:pt="{ className: 'mr-1' }"
							></cl-icon>
							<cl-text size="13px" class="chat-intent-chip__text">{{
								item.text
							}}</cl-text>
						</view>
					</view>
				</scroll-view>
			</view>

			<!-- 后置插槽 -->
			<slot name="tools-append"></slot>
		</view>

		<!-- 主输入区域 -->
		<view class="chat-main">
			<template v-if="inputModeModal === 'text'">
				<!-- 情况1: 无内容 && 无聚焦 - 一行展示，占位符 + 按钮 -->
				<view v-if="!modelValueModal && !isFocused" class="chat-main__single-row">
					<!-- 左侧：切换按钮 -->
					<view class="chat-main__icon-btn" @tap.stop="handleRecording">
						<cl-icon
							:name="inputModeModal === 'text' ? 'fxzh-saying' : 'keyboard-box-line'"
							:size="48"
							color="currentColor"
						></cl-icon>
					</view>

					<!-- 中间：占位符（点击聚焦） -->
					<view class="chat-main__placeholder" @tap="isFocused = true">
						<text class="chat-main__placeholder-text">{{ placeholder }}</text>
					</view>

					<!-- 右侧：实时语音 + 加号 -->
					<view class="chat-main__actions">
						<!-- <realtime-voice-input v-model="modelValueModal" /> -->
						<view class="chat-main__icon-btn" @tap.stop="handleOpenToolbar">
							<cl-icon name="add-circle-line" :size="40"></cl-icon>
						</view>
					</view>
				</view>

				<!-- 情况2: 聚焦 && 无内容 - 两行，输入框在上，按钮在下 -->
				<view v-else-if="isFocused || modelValueModal" class="chat-main__two-rows">
					<!-- 上面：输入框 -->
					<view class="chat-main__input-row">
						<cl-textarea
							v-if="inputModeModal === 'text'"
							v-model="modelValueModal"
							:style="{ maxHeight: inputMaxHeight }"
							clearable
							auto-height
							:border="false"
							:autofocus="true"
							:maxlength="Infinity"
							:showWordLimit="false"
							:disabled="disabled"
							:placeholder="placeholder"
							@confirm="handleConfirm"
							@focus="handleFocus"
							@blur="handleBlur"
						></cl-textarea>
					</view>

					<!-- 下面：按钮行 -->
					<view class="chat-main__button-row">
						<!-- 左侧：切换按钮 -->
						<view class="chat-main__icon-btn" @tap.stop="handleRecording">
							<cl-icon
								:name="
									inputModeModal === 'text' ? 'fxzh-saying' : 'keyboard-box-line'
								"
								:size="40"
								color="currentColor"
							></cl-icon>
						</view>

						<view class="flex-1"></view>

						<!-- 右侧：实时语音 + 加号 -->
						<view class="chat-main__actions">
							<!-- <realtime-voice-input v-model="modelValueModal" /> -->
							<view class="chat-main__icon-btn" @tap.stop="handleConfirm">
								<cl-icon
									:name="`arrow-up-circle-${modelValueModal ? 'fill' : 'line'}`"
									:size="48"
									:color="modelValueModal ? 'primary' : 'default'"
								></cl-icon>
							</view>
						</view>
					</view>
				</view>
			</template>
			<template v-else-if="inputModeModal === 'voice'">
				<view class="chat-main__single-row">
					<!-- 左侧：切换按钮 -->
					<view class="chat-main__icon-btn" @tap.stop="handleRecording">
						<cl-icon name="keyboard-box-line" :size="48" color="currentColor"></cl-icon>
					</view>

					<view class="chat-main__voice flex-1">
						<view
							class="chat-main__voice-hit"
							@touchstart.stop="handlePressStart"
							@touchend.stop="handlePressEnd"
							@touchcancel.stop="handlePressEnd"
						>
							<cl-button type="primary" size="large" class="chat-main__voice-btn">
								按住 说话
							</cl-button>
						</view>
					</view>

					<view class="chat-main__actions">
						<view class="chat-main__icon-btn" @tap.stop="handleOpenToolbar">
							<cl-icon name="add-circle-line" :size="40"></cl-icon>
						</view>
					</view>
				</view>
			</template>
		</view>

		<!-- 底部工具栏 -->
		<actions-popup
			v-model:is-show="showMoreAction"
			@select="handleActionSelect"
		></actions-popup>

		<!-- 语音录制浮层，仅在按住说话时显示 -->
		<voice-record
			v-model:is-show="isShowVoiceRecord"
			ref="voiceRecordRef"
			@finish="handleVoiceRecordFinish"
		></voice-record>
	</simple-card>
</template>

<style scoped lang="scss">
.chat-input-wrapper {
	@apply rounded-none rounded-t-2xl bg-transparent;
	border-width: 0;
}

.chat-tools-area {
	@apply flex flex-col gap-2;
}

.chat-intent-row__inner {
	@apply flex flex-row items-center gap-2 px-1 overflow-x-auto;
}

.chat-intent-chip {
	@apply flex flex-row items-center px-3 py-2 rounded-full bg-white border border-surface-100;
}

.chat-intent-chip__text {
	@apply text-[13px] text-surface-900;
}

.chat-intent-chip--active {
	@apply bg-primary-50 text-primary-700 border-primary-200;
}

.chat-main {
	@apply mt-2;
}

// 单行布局（情况1和3）
.chat-main__single-row {
	@apply flex flex-row items-center bg-white px-3 py-2 shadow-sm;
	gap: 12rpx;
}

// 两行布局（情况2）
.chat-main__two-rows {
	@apply flex flex-col bg-white px-3 py-2 shadow-sm;
	gap: 12rpx;
}

// 输入框行（情况2）
.chat-main__input-row {
	@apply w-full;
}

// 按钮行（情况2）
.chat-main__button-row {
	@apply flex flex-row items-center;
	gap: 12rpx;
}

// 占位符区域（情况1）
.chat-main__placeholder {
	@apply flex-1 flex flex-col items-center;
	min-height: 40px;
	cursor: pointer;
	flex-direction: unset;
}

.chat-main__placeholder-text {
	@apply text-[14px] text-surface-400;
}

// 输入框容器（情况3）
.chat-main__input-wrapper {
	@apply flex-1;

	:deep(.cl-textarea) {
		overflow-y: auto;
		-webkit-overflow-scrolling: touch;
	}
}

// 右侧按钮组
.chat-main__actions {
	@apply flex flex-row items-center;
	gap: 12rpx;
}

// 通用图标按钮
.chat-main__icon-btn {
	@apply flex items-center justify-center text-surface-700;
	cursor: pointer;
	transition: transform 0.2s;

	&:active {
		transform: scale(0.95);
	}
}
</style>
