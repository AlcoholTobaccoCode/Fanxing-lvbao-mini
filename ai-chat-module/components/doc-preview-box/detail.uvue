<script>
import { marked } from "marked";
import { CanvasExporter, WordExporter } from "../../utils/markdown-canvas-exporter.js";
import { saveImageToAlbum, shareImage } from "../../utils/canvas-export.js";
import { sleepWait } from "@/utils";
import { htmlToMarkdown } from "../../utils/html-to-markdown";
import { docGenSessionStore } from "@/cool/store";

import SvEditorToolbar from "../sv-editor/components/sv-editor/sv-editor-toolbar.vue";
import SvEditor from "../sv-editor/components/sv-editor/index.vue";

export default {
	components: {
		SvEditor,
		SvEditorToolbar
	},
	data() {
		return {
			showEdit: false,
			title: "",
			content: "",
			mode: "preview", // preview 或 edit
			messageIndex: -1, // 消息索引（用于编辑后保存）
			editorCtx: null,
			exportImagePath: "", // 导出的图片路径
			isExporting: false, // 导出中状态
			canvasId: "export-canvas", // Canvas ID
			isSaving: false, // 保存中状态
			saveStatus: "", // '' | 'saved'
			saveTimer: null, // 自动保存定时器
			hasContentChanged: false // 内容是否变化
		};
	},
	onLoad() {
		// 接收页面传递的参数
		const eventChannel = this.getOpenerEventChannel();
		eventChannel.on("docData", (data) => {
			this.title = data.title || "";
			this.content = data.content || "";
			this.mode = data.mode || "preview";
			this.messageIndex = data.messageIndex ?? -1;

			uni.setNavigationBarTitle({
				title: this.title
			});

			setTimeout(() => {
				this.showEdit = true;
			}, 1000 * 2);
		});
	},
	mounted() {},
	async onUnload() {
		// 清除自动保存定时器
		if (this.saveTimer) {
			clearTimeout(this.saveTimer);
			this.saveTimer = null;
		}
		// 如果有未保存的内容变化，执行保存
		if (this.hasContentChanged && this.mode === "edit" && this.messageIndex >= 0) {
			await this.doSave();
		}
	},
	methods: {
		ready(e) {
			this.editorCtx = e;
			// 使用接收到的 content 转换为 HTML
			if (this.content) {
				const htmlContent = marked(this.content);
				this.editorCtx.initHtml(htmlContent);
			}
			// 根据模式设置只读状态
			this.updateReadOnlyState();
		},
		updateReadOnlyState() {
			if (this.editorCtx) {
				this.editorCtx.setReadOnly(this.mode === "preview");
			}
		},
		toggleMode() {
			this.mode = this.mode === "preview" ? "edit" : "preview";
			this.updateReadOnlyState();
		},
		// 手动保存入口
		async handleSave() {
			if (this.isSaving || this.mode !== "edit" || this.messageIndex < 0) return;
			await this.doSave();
		},
		// 执行保存
		async doSave() {
			if (!this.editorCtx) return;

			this.isSaving = true;
			try {
				const latestContent = await this.editorCtx.getLastContent();
				const markdownContent = htmlToMarkdown(latestContent?.html || "");

				if (markdownContent) {
					const messages = docGenSessionStore.messages.value;
					if (messages[this.messageIndex]) {
						messages[this.messageIndex].content = markdownContent;
						await docGenSessionStore.saveCurrentSessionSnapshot();
						this.content = markdownContent;
						this.hasContentChanged = false;
					}
				}

				this.saveStatus = "saved";
				setTimeout(() => {
					this.saveStatus = "";
				}, 1000);
			} catch (err) {
				console.error("保存编辑内容失败", err);
				uni.showToast({ title: "保存失败", icon: "none" });
			} finally {
				await sleepWait(800);
				this.isSaving = false;
			}
		},
		// 触发自动保存
		triggerAutoSave() {
			if (this.mode !== "edit") return;
			this.hasContentChanged = true;
			if (this.saveTimer) clearTimeout(this.saveTimer);
			this.saveTimer = setTimeout(() => this.doSave(), 3 * 1000);
		},
		input(e) {
			// console.log("input ==>", e);
			this.triggerAutoSave();
		},
		epaste(e) {
			console.log("epaste ==>", e);
		},
		overMax(e) {
			console.log("overMax ==>", e);
		},
		changeTool(e) {
			console.log("changeTool ==>", e);
		},
		onToolMoreItem(e) {
			console.log("onToolMoreItem ==>", e);

			if (e.name == "clear") {
				uni.showModal({
					title: "提示",
					content: "确定要清空内容吗？",
					success: ({ confirm }) => {
						if (confirm) {
							this.editorCtx.clear();
						}
					}
				});
			}
		},
		async moreItemConfirm(e) {
			console.log("moreItemConfirm ==>", e);
			// 关闭弹窗
			this.$refs.toolbarRef.closeMorePop();
		},
		async onExport() {
			console.log("onExport ==>", this.content);

			// 显示导出选项
			uni.showActionSheet({
				itemList: ["导出为图片", "导出为 Word"],
				success: (res) => {
					if (res.tapIndex === 0) {
						// 导出为图片
						this.exportAsImage();
					} else if (res.tapIndex === 1) {
						// 导出为 Word
						this.exportAsWord();
					}
				}
			});
		},

		// 导出为图片
		async exportAsImage() {
			if (this.isExporting) {
				return;
			}

			// 检查编辑器是否已加载
			if (!this.showEdit || !this.editorCtx) {
				uni.showToast({
					title: "编辑器未加载完成",
					icon: "none"
				});
				return;
			}

			this.isExporting = true;
			uni.showLoading({
				title: "正在生成图片..."
			});

			// 延迟一下确保 DOM 渲染完成
			await new Promise((resolve) => setTimeout(resolve, 300));

			try {
				// 获取编辑器最新内容
				const latestContent = await this.editorCtx.getLastContent();
				const exportContent = latestContent?.text || this.content;

				// 使用封装好的 CanvasExporter 导出图片（支持分页）
				const imagePaths = await CanvasExporter.exportToImage({
					canvasId: this.canvasId,
					title: this.title,
					content: exportContent
				});

				this.exportImagePath = imagePaths;
				uni.hideLoading();

				// 显示操作选项
				if (imagePaths.length > 1) {
					uni.showToast({
						title: `已生成 ${imagePaths.length} 张图片`,
						icon: "success",
						duration: 2000
					});
					await sleepWait(2000);
				}

				this.showImageActions(imagePaths);
			} catch (error) {
				console.error("导出图片失败:", error);
				uni.hideLoading();
				uni.showToast({
					title: error.message || "导出失败",
					icon: "none",
					duration: 2000
				});
			} finally {
				this.isExporting = false;
			}
		},

		// 显示图片操作选项
		showImageActions(imagePaths) {
			const isMultiple = imagePaths.length > 1;
			const itemList = isMultiple ? ["保存全部", "预览全部"] : ["保存", "分享", "预览"];

			uni.showActionSheet({
				itemList: itemList,
				success: (res) => {
					if (isMultiple) {
						if (res.tapIndex === 0) {
							// 保存全部
							this.saveAllToAlbum(imagePaths);
						} else if (res.tapIndex === 1) {
							// 预览全部
							this.previewAllImages(imagePaths);
						}
					} else {
						if (res.tapIndex === 0) {
							// 保存到相册
							this.saveToAlbum(imagePaths[0]);
						} else if (res.tapIndex === 1) {
							// 分享图片
							this.shareImageFile(imagePaths[0]);
						} else if (res.tapIndex === 2) {
							// 预览图片
							this.previewImage(imagePaths[0]);
						}
					}
				}
			});
		},

		// 导出为 Word
		async exportAsWord() {
			if (this.isExporting) {
				return;
			}

			// 检查编辑器是否已加载
			if (!this.editorCtx) {
				uni.showToast({
					title: "编辑器未加载完成",
					icon: "none"
				});
				return;
			}

			this.isExporting = true;
			uni.showLoading({
				title: "正在生成 Word..."
			});

			try {
				// 获取编辑器最新内容
				const latestContent = await this.editorCtx.getLastContent();
				// 将 HTML 转换为 Markdown（后端 API 需要 Markdown 格式）
				const markdownContent = htmlToMarkdown(latestContent?.html || "") || this.content;

				const filePath = await WordExporter.exportToWord({
					content: markdownContent,
					filename: `${this.title}.docx`
				});

				await sleepWait(1000);

				uni.hideLoading();

				// 直接打开文件
				uni.openDocument({
					filePath: filePath,
					showMenu: true,
					success: () => {},
					fail: (err) => {
						console.error("打开文件失败:", err);
						uni.showToast({
							title: "打开文件失败",
							icon: "none"
						});
					}
				});
			} catch (error) {
				console.error("导出 Word 失败:", error);
				uni.hideLoading();
				uni.showToast({
					title: error.message || "导出失败",
					icon: "none",
					duration: 2000
				});
			} finally {
				this.isExporting = false;
			}
		},

		// 保存到相册
		async saveToAlbum(imagePath) {
			try {
				await saveImageToAlbum(imagePath);
			} catch (error) {
				console.error("保存到相册失败:", error);
			}
		},

		// 分享图片
		async shareImageFile(imagePath) {
			try {
				await shareImage(imagePath);
			} catch (error) {
				console.error("分享图片失败:", error);
				uni.showToast({
					title: "分享失败",
					icon: "none"
				});
			}
		},

		// 预览图片
		previewImage(imagePath) {
			uni.previewImage({
				urls: [imagePath],
				current: 0
			});
		},

		// 保存全部到相册
		async saveAllToAlbum(imagePaths) {
			uni.showLoading({
				title: "正在保存..."
			});

			let successCount = 0;
			for (let i = 0; i < imagePaths.length; i++) {
				try {
					await saveImageToAlbum(imagePaths[i]);
					successCount++;
				} catch (error) {
					console.error(`保存第 ${i + 1} 张图片失败:`, error);
				}
			}

			uni.hideLoading();
			uni.showToast({
				title: `已保存 ${successCount}/${imagePaths.length} 张`,
				icon: successCount > 0 ? "success" : "none"
			});
		},

		// 预览全部图片
		previewAllImages(imagePaths) {
			uni.previewImage({
				urls: imagePaths,
				current: 0
			});
		}
	}
};
</script>

<template>
	<view class="example">
		<!-- 头部标题栏 -->
		<view class="page-header">
			<view class="flex flex-row gap-2">
				<cl-button @click="toggleMode">
					{{ mode === "preview" ? "编辑" : "预览" }}
				</cl-button>
				<cl-button v-if="mode === 'edit'" :loading="isSaving" @click="handleSave">
					{{ saveStatus === "saved" ? "已保存" : "保存" }}
				</cl-button>
				<cl-button text @click="onExport"> 导出 </cl-button>
			</view>
		</view>

		<!-- 编辑器容器 -->
		<template v-if="!showEdit">
			<view class="loading-view">
				<cl-loading :size="42"></cl-loading>
				<cl-text color="info">文档加载中...</cl-text>
			</view>
		</template>
		<template v-else>
			<view class="page-editor-container">
				<sv-editor
					pasteMode="origin"
					:read-only="mode === 'preview'"
					@ready="ready"
					@input="input"
					@overmax="overMax"
					@epaste="epaste"
				></sv-editor>
			</view>

			<!-- 工具栏 - 仅编辑模式显示 -->
			<view v-if="mode === 'edit'" class="page-editor-toolbar-container">
				<sv-editor-toolbar
					ref="toolbarRef"
					:style-tools="[
						'header',
						'divider',
						'bold',
						'italic',
						'underline',
						'strike',
						'align',
						'color',
						'backgroundColor',
						'removeformat'
					]"
					:tools="['style', 'undo', 'redo']"
					@changeTool="changeTool"
					@toolMoreItem="onToolMoreItem"
					@moreItemConfirm="moreItemConfirm"
				>
					<template #setting>
						<button size="mini" @click="onExport">导出</button>
					</template>
				</sv-editor-toolbar>
			</view>
		</template>

		<!-- 隐藏的 Canvas 用于导出图片 -->
		<canvas
			type="2d"
			:id="canvasId"
			style="position: fixed; top: -9999px; left: -9999px; width: 750px; height: 1200px"
		></canvas>
	</view>
</template>

<style lang="scss">
.example {
	box-sizing: border-box;
	height: calc(100vh - var(--window-top) - env(safe-area-inset-bottom));
	display: flex;
	flex-direction: column;

	.page-header {
		display: flex;
		flex-direction: row;
		align-items: center;
		justify-content: flex-end;
		padding: 8px 20px;
		border-bottom: 1px solid #e5e7eb;
		background-color: #f9fafb;
	}

	.page-editor-container {
		flex: 1;
		overflow-y: auto;
		box-sizing: border-box;
		padding: 10px 20px;
		padding-bottom: 20px;
	}

	.page-editor-toolbar-container {
		position: sticky;
		bottom: 0;
		width: 100%;
	}
}
</style>
