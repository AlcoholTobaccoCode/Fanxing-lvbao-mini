<script lang="ts" setup>
import { ref, computed, onMounted, onUnmounted } from "vue";
import { useUi } from "@/uni_modules/cool-ui";
import { Logger } from "@/cool/utils/log";
import {
	ListKnowledge,
	CreateKnowledge,
	RenameKnowledge,
	DeleteKnowledge,
	UpdateKnowledgeNote,
	GetKnowledgeDetail,
	type KnowledgeObject,
	type KnowledgeObjectType,
	type CreateKnowledgePayload,
	type ListKnowledgeQuery
} from "@/api/knowledge";
import { uploadToOss } from "@/utils/aliyun/oss";

import AppPage from "@/components/common/layout/app-page.uvue";
import AddActionMenu from "./add-action.uvue";
import SvEditor from "@/ai-chat-module/components/sv-editor/components/sv-editor/index.vue";
import SvEditorToolbar from "@/ai-chat-module/components/sv-editor/components/sv-editor/sv-editor-toolbar.vue";

const log = new Logger("KnowledgeBasePage");
const ui = useUi();

// 筛选器
const filters = [
	{ label: "全部", value: "all" },
	{ label: "文件", value: "file" },
	{ label: "图片", value: "image" },
	{ label: "笔记", value: "note" }
];

// 类型映射：API 类型 (1,2,3) ↔ 前端类型 (file, image, note)
const typeMap: Record<number, string> = {
	1: "file",
	2: "image",
	3: "note"
};

const reverseTypeMap: Record<string, KnowledgeObjectType> = {
	file: 1,
	image: 2,
	note: 3
};

// 知识库项目数据
const knowledgeItems = ref<KnowledgeObject[]>([]);

//#region 数据筛选
// 状态变量
const currentFilter = ref("all");
const searchKeyword = ref("");
const loading = ref(false);

// 分页状态
const currentPage = ref(1);
const pageSize = ref(20);
const hasMore = ref(true);
const refreshing = ref(false);
const loadingMore = ref(false);

//#endregion

//#region 预览弹窗状态
// 弹窗显示状态
const showImagePopup = ref(false);
const showRenamePopup = ref(false);
const showNoteEditorPopup = ref(false);

// 当前预览的项目
const currentPreviewItem = ref<KnowledgeObject | null>(null);

// 重命名相关
const renameInputValue = ref("");
const currentRenameItem = ref<KnowledgeObject | null>(null);
const MAX_TITLE_LENGTH = 24;

// 笔记编辑相关
const noteTitle = ref("");
const noteContent = ref("");
const noteEditorMode = ref<"edit" | "preview">("preview");
const isEditingNote = ref(false);
const currentEditNoteId = ref<number | null>(null);
const noteEditorCtx = ref<any>(null);

// 当前预览项的 OSS URL
const currentPreviewUrl = computed(() => {
	if (!currentPreviewItem.value) return "";
	return getOssUrl(currentPreviewItem.value);
});

// 切换筛选器
const changeFilter = (filterValue: string) => {
	log.info("切换筛选器 - 原值:", currentFilter.value, "新值:", filterValue);
	currentFilter.value = filterValue;
	log.info("切换筛选器 - 映射类型:", reverseTypeMap[filterValue]);
	loadData();
};

//#endregion

//#region 辅助方法

// 获取图标名称（RemixIcon）
const getIconName = (type: KnowledgeObjectType) => {
	const typeStr = typeMap[type];
	switch (typeStr) {
		case "file":
			return "file-text-line";
		case "image":
			return "image-line";
		case "note":
			return "sticky-note-line";
		default:
			return "file-text-line";
	}
};

// 获取图标颜色
const getIconColor = (type: KnowledgeObjectType) => {
	const typeStr = typeMap[type];
	switch (typeStr) {
		case "file":
			return "#3498db";
		case "image":
			return "#e74c3c";
		case "note":
			return "#f39c12";
		default:
			return "#95a5a6";
	}
};

// 获取图标背景色
const getIconBgColor = (type: KnowledgeObjectType) => {
	const typeStr = typeMap[type];
	switch (typeStr) {
		case "file":
			return "rgba(52, 152, 219, 0.1)";
		case "image":
			return "rgba(231, 76, 60, 0.1)";
		case "note":
			return "rgba(243, 156, 18, 0.1)";
		default:
			return "rgba(149, 165, 166, 0.1)";
	}
};

// 获取类型标签
const getTypeLabel = (type: KnowledgeObjectType | string) => {
	const typeStr = typeof type === "number" ? typeMap[type] : type;
	switch (typeStr) {
		case "file":
			return "文件";
		case "image":
			return "图片";
		case "note":
			return "笔记";
		default:
			return "未知";
	}
};

// 格式化时间
const formatTime = (dateStr: string) => {
	if (!dateStr) return "";
	try {
		// 处理 ISO 格式时间：2026-01-08T03:05:07
		const date = new Date(dateStr);
		const year = date.getFullYear();
		const month = String(date.getMonth() + 1).padStart(2, "0");
		const day = String(date.getDate()).padStart(2, "0");
		const hours = String(date.getHours()).padStart(2, "0");
		const minutes = String(date.getMinutes()).padStart(2, "0");
		return `${year}-${month}-${day} ${hours}:${minutes}`;
	} catch (error) {
		log.error("时间格式化失败:", error);
		return dateStr;
	}
};

//#endregion

//#region 辅助方法

// 获取完整的 OSS URL
const getOssUrl = (item: KnowledgeObject): string => {
	return item.oss_url || "";
};

//#endregion

//#region CRUD

// 加载数据
const loadData = async (isLoadMore: boolean = false) => {
	// 如果是加载更多且没有更多数据,直接返回
	if (isLoadMore && !hasMore.value) {
		return;
	}

	if (isLoadMore) {
		loadingMore.value = true;
	} else {
		loading.value = true;
		currentPage.value = 1; // 重置页码
	}

	try {
		// 构建查询参数
		const params: ListKnowledgeQuery = {
			page: isLoadMore ? currentPage.value : 1,
			page_size: pageSize.value
		};

		// 类型筛选
		if (currentFilter.value !== "all") {
			params.type = reverseTypeMap[currentFilter.value];
		}

		// 标题搜索
		if (searchKeyword.value.trim()) {
			params.title = searchKeyword.value.trim();
		}

		log.info("加载数据 - 当前筛选:", currentFilter.value);
		log.info("加载数据 - 请求参数:", params);

		const response = await ListKnowledge(params);
		log.info("加载数据 - 响应数据:", response);

		// 更新数据
		if (isLoadMore) {
			// 加载更多:追加数据
			knowledgeItems.value = [...knowledgeItems.value, ...response.items];
		} else {
			// 首次加载或刷新:替换数据
			knowledgeItems.value = response.items;
		}

		// 更新分页状态
		hasMore.value = response.hasMore;
		currentPage.value = response.page;
	} catch (error: any) {
		ui.showToast({ message: error?.message || "加载失败", type: "error" });
		log.error("加载知识库数据失败:", error);
	} finally {
		loading.value = false;
		loadingMore.value = false;
	}
};

// 下拉刷新
const onRefresh = async () => {
	refreshing.value = true;
	try {
		await loadData(false);
	} finally {
		refreshing.value = false;
	}
};

// 上拉加载更多
const onLoadMore = async () => {
	if (!hasMore.value || loadingMore.value) {
		return;
	}
	currentPage.value += 1;
	await loadData(true);
};

// 重命名项目
const renameItem = (item: KnowledgeObject) => {
	currentRenameItem.value = item;
	renameInputValue.value = item.title;
	showRenamePopup.value = true;
};

// 确认重命名
const confirmRename = async () => {
	if (!currentRenameItem.value) return;

	const newTitle = renameInputValue.value.trim();

	// 验证
	if (!newTitle) {
		ui.showToast({ message: "名称不能为空", type: "error" });
		return;
	}

	if (newTitle.length > MAX_TITLE_LENGTH) {
		ui.showToast({ message: `名称不能超过${MAX_TITLE_LENGTH}个字符`, type: "error" });
		return;
	}

	try {
		await RenameKnowledge(currentRenameItem.value.id, { title: newTitle });
		ui.showToast({ message: "重命名成功", type: "success" });
		showRenamePopup.value = false;
		loadData();
	} catch (error: any) {
		ui.showToast({ message: error?.message || "重命名失败", type: "error" });
		log.error("重命名失败:", error);
	}
};

// 取消重命名
const cancelRename = () => {
	showRenamePopup.value = false;
	renameInputValue.value = "";
	currentRenameItem.value = null;
};

// 打开笔记编辑器（新建）
const openNoteEditor = () => {
	isEditingNote.value = false;
	currentEditNoteId.value = null;
	noteTitle.value = "";
	noteContent.value = "";
	noteEditorMode.value = "edit";
	showNoteEditorPopup.value = true;
};

// 打开笔记编辑器（编辑）
const editNote = (item: KnowledgeObject) => {
	isEditingNote.value = true;
	currentEditNoteId.value = item.id;
	noteTitle.value = item.title;
	noteContent.value = item.textContent || "";
	// 不在这里设置 mode，让调用者决定
	showNoteEditorPopup.value = true;
};

// 编辑器准备就绪
const handleEditorReady = async (ctx: any) => {
	noteEditorCtx.value = ctx;

	// 如果是编辑模式，调用详情接口获取完整内容
	if (isEditingNote.value && currentEditNoteId.value) {
		try {
			// 显示 loading
			uni.showLoading({ title: "加载中...", mask: true });

			// 调用详情接口获取完整内容
			const fullItem = await GetKnowledgeDetail(currentEditNoteId.value);

			if (fullItem && fullItem.textContent) {
				log.info("编辑器准备就绪 - 获取完整内容成功，长度:", fullItem.textContent.length);
				ctx.initHtml(fullItem.textContent);
				// 同时更新 noteContent，保持状态一致
				noteContent.value = fullItem.textContent;
			} else {
				log.warn("编辑器准备就绪 - 详情接口返回内容为空");
				// 降级：使用列表数据
				if (noteContent.value) {
					ctx.initHtml(noteContent.value);
				}
			}
		} catch (error) {
			log.error("编辑器准备就绪 - 获取完整内容失败:", error);
			// 降级：使用列表数据
			if (noteContent.value) {
				log.info("编辑器准备就绪 - 降级使用列表数据");
				ctx.initHtml(noteContent.value);
			} else {
				ui.showToast({ message: "加载笔记内容失败", type: "error" });
			}
		} finally {
			// 隐藏 loading
			uni.hideLoading();
		}
	} else if (noteContent.value) {
		// 新建模式：使用 noteContent
		log.info("编辑器准备就绪 - 使用 noteContent 初始化");
		ctx.initHtml(noteContent.value);
	}

	// 设置只读状态
	ctx.setReadOnly(noteEditorMode.value === "preview");
	log.info("编辑器准备就绪 - 设置只读状态:", noteEditorMode.value === "preview");
};

// 切换编辑/预览模式
const toggleNoteEditorMode = () => {
	noteEditorMode.value = noteEditorMode.value === "edit" ? "preview" : "edit";
	if (noteEditorCtx.value) {
		noteEditorCtx.value.setReadOnly(noteEditorMode.value === "preview");
	}
};

// 保存笔记
const saveNote = async () => {
	const title = noteTitle.value.trim();
	if (!title) {
		ui.showToast({ message: "标题不能为空", type: "error" });
		return;
	}

	try {
		// 获取编辑器内容（HTML格式）
		let htmlContent = noteContent.value;

		if (noteEditorCtx.value && noteEditorCtx.value.getLastContent) {
			const content = await noteEditorCtx.value.getLastContent();
			htmlContent = content.html;
		} else {
			log.warn("保存笔记 - 编辑器上下文不可用或没有 getLastContent 方法");
		}

		if (isEditingNote.value && currentEditNoteId.value) {
			// 编辑模式：更新笔记内容
			await UpdateKnowledgeNote(currentEditNoteId.value, {
				action: "update",
				content: htmlContent
			});

			// 只在标题修改时调用重命名API
			const originalItem = knowledgeItems.value.find(
				(item) => item.id === currentEditNoteId.value
			);
			if (originalItem && originalItem.title !== title) {
				await RenameKnowledge(currentEditNoteId.value, { title });
			}

			ui.showToast({ message: "保存成功", type: "success" });
		} else {
			// 新建模式：创建笔记
			const payload: CreateKnowledgePayload = {
				type: 3,
				title,
				textContent: htmlContent
			};
			await CreateKnowledge(payload);
			ui.showToast({ message: "创建成功", type: "success" });
		}
		showNoteEditorPopup.value = false;
		loadData();
	} catch (error: any) {
		ui.showToast({ message: error?.message || "保存失败", type: "error" });
		log.error("保存笔记失败:", error);
	}
};

// 取消笔记编辑
const cancelNoteEdit = () => {
	showNoteEditorPopup.value = false;
	noteTitle.value = "";
	noteContent.value = "";
	noteEditorMode.value = "preview";
	isEditingNote.value = false;
	currentEditNoteId.value = null;
	noteEditorCtx.value = null;
};

// 删除项目
const deleteItem = async (item: KnowledgeObject) => {
	uni.showModal({
		title: "确认删除",
		content: `确定要删除"${item.title}"吗？`,
		success: async (res) => {
			if (res.confirm) {
				try {
					await DeleteKnowledge(item.id);
					ui.showToast({ message: "删除成功", type: "success" });
					loadData();
				} catch (error: any) {
					ui.showToast({ message: error?.message || "删除失败", type: "error" });
					log.error("删除失败:", error);
				}
			}
		}
	});
};

// 选择本地文件（用于"文件"按钮）
const chooseLocalFile = async (): Promise<Array<{ tempFilePath: string; name: string }> | null> => {
	// #ifdef MP-WEIXIN
	// 微信小程序：跳转到 WebView 上传页面
	uni.navigateTo({
		url: "/pages/file-upload-webview/index"
	});
	return null; // 页面会通过事件总线返回结果
	// #endif

	// #ifndef MP-WEIXIN
	// 其他平台：使用 uni.chooseFile() API
	return new Promise((resolve) => {
		uni.chooseFile({
			count: 9,
			type: "all", // 支持所有文件类型
			success: (res) => {
				// @ts-ignore
				const files = res.tempFiles.map((file: any) => ({
					tempFilePath: file.path,
					name: file.name
				}));
				resolve(files);
			},
			fail: () => resolve(null)
		});
	});
	// #endif
};

// 从聊天记录选择文件（用于"记录"按钮，仅微信小程序）
const chooseMessageFile = async (): Promise<Array<{
	tempFilePath: string;
	name: string;
}> | null> => {
	return new Promise((resolve) => {
		// #ifdef MP-WEIXIN
		// @ts-ignore
		uni.chooseMessageFile({
			count: 9,
			type: "all", // 支持所有文件类型
			success: (res) => {
				const files = res.tempFiles.map((file: any) => ({
					tempFilePath: file.path,
					name: file.name
				}));
				resolve(files);
			},
			fail: () => {
				resolve(null);
			}
		});
		// #endif

		// #ifndef MP-WEIXIN
		resolve(null);
		// #endif
	});
};

// #ifdef MP-WEIXIN
// 处理 WebView 上传成功（通过事件总线）
const handleWebviewUploadSuccess = async (
	files: Array<{ name: string; ossUrl: string; type: KnowledgeObjectType }>
) => {
	// 创建知识库条目
	for (const file of files) {
		await CreateKnowledge({
			type: file.type,
			title: file.name,
			filename: file.name,
			ossUrl: file.ossUrl,
			textContent: null
		});
	}

	// 刷新列表
	await loadData();
	ui.showToast({ message: `成功上传 ${files.length} 个文件` });
};
// #endif

// 批量上传文件
const uploadFiles = async (files: Array<{ tempFilePath: string; name: string }>) => {
	let successCount = 0;
	let failCount = 0;

	uni.showLoading({ title: `上传中 0/${files.length}` });

	for (let i = 0; i < files.length; i++) {
		const file = files[i];
		try {
			uni.showLoading({ title: `上传中 ${i + 1}/${files.length}` });

			const uploadResult = await uploadToOss({
				filePath: file.tempFilePath,
				dirPrefix: "knowledge-base"
			});

			const isImage = uploadResult.ext.mimeType.startsWith("image/");
			const finalType = isImage ? 2 : 1;

			const payload: CreateKnowledgePayload = {
				type: finalType,
				title: file.name,
				filename: uploadResult.key.split("/").pop() || file.name,
				ossUrl: uploadResult.ext.oss_url,
				textContent: null
			};

			await CreateKnowledge(payload);
			successCount++;
		} catch (error: any) {
			log.error(`文件上传失败: ${file.name}`, error);
			failCount++;
		}
	}

	uni.hideLoading();

	if (failCount === 0) {
		ui.showToast({ message: `成功上传 ${successCount} 个文件`, type: "success" });
	} else {
		ui.showToast({ message: `成功 ${successCount} 个，失败 ${failCount} 个`, type: "error" });
	}

	loadData();
};

// 创建新项目
const createItem = async (type: string) => {
	try {
		// 文件类型需要先上传
		if (type === "file") {
			// 从本地选择文件
			const chooseResult = await chooseLocalFile();
			if (!chooseResult || chooseResult.length === 0) {
				return; // 用户取消选择
			}

			// 批量上传文件
			await uploadFiles(chooseResult);
		} else if (type === "record") {
			// #ifdef MP-WEIXIN
			// 从聊天记录选择文件
			const chooseResult = await chooseMessageFile();
			if (!chooseResult || chooseResult.length === 0) {
				return; // 用户取消选择
			}

			// 批量上传文件
			await uploadFiles(chooseResult);
			// #endif

			// #ifndef MP-WEIXIN
			ui.showToast({
				message: "此功能仅在微信小程序中可用",
				type: "error"
			});
			// #endif
		} else if (type === "note") {
			// 笔记类型打开编辑弹窗
			openNoteEditor();
		}
	} catch (error: any) {
		uni.hideLoading();
		ui.showToast({ message: error?.message || "创建失败", type: "error" });
		log.error("创建失败:", error);
	}
};

//#endregion

// 打开详情页
const openDetail = async (item: KnowledgeObject) => {
	log.info("打开详情:", item);
	log.info("item.type:", item.type);

	currentPreviewItem.value = item;

	// 获取完整的 OSS URL
	const ossUrl = getOssUrl(item);
	log.info("ossUrl:", ossUrl);

	// 1. 如果是图片类型，打开图片预览弹窗
	if (item.type === 2) {
		log.info("打开图片预览弹窗");
		showImagePopup.value = true;
		return;
	}

	// 2. 如果是笔记类型，打开编辑器弹窗(预览模式)
	if (item.type === 3) {
		log.info("打开笔记编辑器弹窗(预览模式)");
		noteEditorMode.value = "preview"; // 先设置模式
		editNote(item); // 再打开编辑器
		return;
	}

	// 3. 如果是文件类型（文档、音频、视频），使用 uni.openDocument
	if (item.type === 1) {
		if (!ossUrl) {
			ui.showToast({ message: "文件地址不存在", type: "error" });
			return;
		}

		try {
			// 先下载文件到本地
			uni.showLoading({ title: "下载中..." });
			const downloadResult = await new Promise<UniApp.DownloadSuccessData>(
				(resolve, reject) => {
					uni.downloadFile({
						url: ossUrl,
						success: (res) => {
							if (res.statusCode === 200) {
								resolve(res);
							} else {
								reject(new Error("下载失败"));
							}
						},
						fail: reject
					});
				}
			);

			uni.hideLoading();

			// 打开文档
			uni.openDocument({
				filePath: downloadResult.tempFilePath,
				showMenu: true,
				success: () => {
					log.info("文档打开成功");
				},
				fail: (err) => {
					log.error("文档打开失败:", err);
					ui.showToast({ message: "文档打开失败", type: "error" });
				}
			});
		} catch (error: any) {
			uni.hideLoading();
			log.error("文件下载失败:", error);
			ui.showToast({ message: error?.message || "文件下载失败", type: "error" });
		}
	}
};

onMounted(() => {
	loadData();

	// #ifdef MP-WEIXIN
	// 监听文件上传成功事件
	uni.$on("fileUploadSuccess", handleWebviewUploadSuccess);
	// #endif
});

// #ifdef MP-WEIXIN
onUnmounted(() => {
	// 移除事件监听
	uni.$off("fileUploadSuccess", handleWebviewUploadSuccess);
});
// #endif
</script>

<template>
	<app-page
		title=""
		back-top
		:chat-list-btn="false"
		:title-action="false"
		:hide-float-menu="true"
		:hide-header="true"
		titlePlaceholder=""
	>
		<template #content>
			<view class="app-container">
				<!-- 顶部导航栏 -->
				<view class="nav-bar">
					<cl-input
						v-model="searchKeyword"
						placeholder="搜索知识库内容..."
						:border="false"
						class="w-full"
					>
						<template #append>
							<cl-button
								text
								type="primary"
								size="small"
								icon="sousuo_2"
								:pt="{
									className: 'ml-2'
								}"
								@click="loadData"
							></cl-button>
						</template>
					</cl-input>
				</view>

				<!-- 类型筛选栏 -->
				<view class="filter-container">
					<scroll-view scroll-x :show-scrollbar="false" class="filter-scroll">
						<view class="filter-items">
							<view
								v-for="(filter, index) in filters"
								:key="index"
								class="filter-item"
								:class="{ 'filter-item--active': currentFilter === filter.value }"
								@tap="changeFilter(filter.value)"
							>
								<cl-text
									class="filter-text"
									:color="currentFilter === filter.value ? '#fff' : '#666'"
									>{{ filter.label }}</cl-text
								>
							</view>
						</view>
					</scroll-view>
				</view>

				<!-- 内容区域 -->
				<scroll-view
					class="content-area"
					scroll-y
					refresher-enabled
					:refresher-triggered="refreshing"
					@refresherrefresh="onRefresh"
					@scrolltolower="onLoadMore"
					:lower-threshold="100"
				>
					<!-- 空状态 -->
					<view v-if="knowledgeItems.length === 0 && !loading" class="empty-state">
						<cl-icon name="inbox-line" :size="120" color="#d0d0d0" />
						<cl-text color="#999">暂无数据</cl-text>
						<cl-text color="#999">等待你的添加</cl-text>
					</view>

					<!-- 列表项 -->
					<cl-list>
						<cl-list-item
							v-for="item in knowledgeItems"
							:key="item.id"
							swipeable
							hoverable
							@tap="openDetail(item)"
							:pt="{
								className: 'list-item !rounded-xl !mb-[8px]',
								inner: { className: 'py-3' }
							}"
						>
							<!-- 图标插槽 -->
							<template #icon>
								<view
									class="item-icon"
									:style="{ backgroundColor: getIconBgColor(item.type) }"
								>
									<cl-icon
										:name="getIconName(item.type)"
										:size="42"
										:color="getIconColor(item.type)"
									/>
								</view>
							</template>

							<!-- 默认插槽：信息和菜单 -->
							<view class="item-content">
								<cl-text ellipsis>{{ item.title }}</cl-text>
								<view class="item-meta">
									<cl-text class="item-type">{{
										getTypeLabel(item.type)
									}}</cl-text>
									<cl-text class="item-time">{{
										formatTime(item.createdAt)
									}}</cl-text>
								</view>
							</view>
							<!-- <cl-icon
							name="more-line"
							:size="32"
							color="#999"
							class="ml-2 flex-shrink-0"
						/> -->

							<!-- 左滑显示的操作按钮 -->
							<template #swipe-right>
								<view class="swipe-actions">
									<view
										class="swipe-btn swipe-btn--rename"
										@tap.stop="renameItem(item)"
									>
										<cl-icon name="edit-line" :size="32" color="#fff" />
										<cl-text color="#fff">重命名</cl-text>
									</view>
									<view
										class="swipe-btn swipe-btn--delete"
										@tap.stop="deleteItem(item)"
									>
										<cl-icon name="delete-bin-line" :size="32" color="#fff" />
										<cl-text color="#fff">删除</cl-text>
									</view>
								</view>
							</template>
						</cl-list-item>
					</cl-list>

					<!-- 加载更多提示 -->
					<view v-if="knowledgeItems.length > 0" class="load-more-tip">
						<cl-text v-if="loadingMore" color="#999" size="14">加载中...</cl-text>
						<cl-text v-else-if="!hasMore" color="#999" size="14">没有更多了</cl-text>
					</view>
				</scroll-view>
			</view>

			<!-- 知识库新增浮动菜单 -->
			<add-action-menu @create="createItem"></add-action-menu>

			<!-- 图片预览弹窗 -->
			<cl-popup v-model="showImagePopup" direction="bottom" size="60%">
				<view class="popup-container">
					<view class="popup-header">
						<cl-text bold size="18">{{ currentPreviewItem?.title }}</cl-text>
					</view>
					<view class="popup-content">
						<cl-image
							v-if="currentPreviewUrl"
							:src="currentPreviewUrl"
							mode="aspectFit"
							:preview="true"
							width="100%"
							height="100%"
							class="preview-image"
						/>
						<cl-text v-else color="#999">暂无图片</cl-text>
					</view>
				</view>
			</cl-popup>

			<!-- 重命名弹窗 -->
			<cl-popup v-model="showRenamePopup" direction="center" @close="cancelRename">
				<view class="rename-popup-container">
					<view class="rename-popup-header">
						<cl-text bold>重命名</cl-text>
					</view>
					<view class="rename-popup-content">
						<cl-input
							v-model="renameInputValue"
							placeholder="请输入新名称"
							:maxlength="MAX_TITLE_LENGTH"
							class="rename-input"
						/>
						<view class="char-count">
							<cl-text color="#999"
								>{{ renameInputValue.length }}/{{ MAX_TITLE_LENGTH }}</cl-text
							>
						</view>
					</view>
					<view class="rename-popup-footer">
						<cl-button text @tap="cancelRename">取消</cl-button>
						<cl-button type="primary" @tap="confirmRename">确定</cl-button>
					</view>
				</view>
			</cl-popup>

			<!-- 笔记编辑器弹窗 -->
			<cl-popup
				v-model="showNoteEditorPopup"
				direction="bottom"
				size="90%"
				@close="cancelNoteEdit"
			>
				<view class="note-editor-popup-container">
					<!-- 头部 -->
					<view class="note-editor-header">
						<view class="header-title-row">
							<cl-text bold size="18">{{
								isEditingNote ? "编辑笔记" : "新建笔记"
							}}</cl-text>
							<view class="header-actions">
								<cl-button
									v-if="noteEditorMode === 'preview'"
									size="small"
									@tap="toggleNoteEditorMode"
								>
									编辑
								</cl-button>
								<template v-else>
									<cl-button size="small" text @tap="toggleNoteEditorMode">
										预览
									</cl-button>
									<cl-button size="small" type="primary" @tap="saveNote">
										保存
									</cl-button>
								</template>
							</view>
						</view>
						<!-- 标题输入 -->
						<cl-input
							v-model="noteTitle"
							placeholder="请输入标题"
							:maxlength="MAX_TITLE_LENGTH"
							:border="false"
							:pt="{
								className: 'note-title-input'
							}"
						/>
					</view>

					<!-- 编辑器内容区 -->
					<view class="note-editor-content">
						<sv-editor
							v-if="showNoteEditorPopup"
							pasteMode="origin"
							:read-only="noteEditorMode === 'preview'"
							placeholder="现在的想法是..."
							@ready="handleEditorReady"
						></sv-editor>
					</view>

					<!-- 工具栏 - 仅编辑模式显示 -->
					<view v-if="noteEditorMode === 'edit'" class="note-editor-toolbar">
						<sv-editor-toolbar
							:style-tools="[
								'header',
								'divider',
								'bold',
								'italic',
								'underline',
								'strike',
								'align',
								'color',
								'backgroundColor',
								'removeformat'
							]"
							:tools="['style', 'undo', 'redo']"
						></sv-editor-toolbar>
					</view>
				</view>
			</cl-popup>
		</template>
	</app-page>
</template>

<style lang="scss" scoped>
// 通用样式变量
$nav-height: 68px;
$filter-height: 68px;
$content-top: 120px;

// 通用混合类
@mixin card-base {
	@apply bg-white;
	border-radius: 12px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

@mixin hover-lift {
	transition: all 0.2s ease;
	&:hover {
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
	}
}

@mixin flex-center {
	@apply flex items-center justify-center;
}

// 容器样式
.app-container {
	@apply w-full relative;
	min-height: 100vh;
	background: #f5f5f5;
}

// 导航栏样式
.nav-bar {
	@apply flex items-center justify-center box-border;
	height: 54px;
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
	padding: 8px 16px;
}

// 筛选栏样式
.filter-container {
	@apply w-full bg-white;
	padding: 12px 20px;
	box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
}

.filter-scroll {
	@apply w-full;
	white-space: nowrap;
}

.filter-items {
	width: fit-content;
	display: flex;
	flex-direction: row;
	gap: 4px;
}

.filter-item {
	@apply bg-transparent;
	padding: 6px 16px;
	border-radius: 16px;
	font-size: 14px;
	color: #666;
	white-space: nowrap;
	transition: all 0.3s ease;
}

.filter-item--active {
	@apply text-white;
	background: #667eea;
}

.filter-text {
	font-size: 14px;
}

// 内容区域样式
.content-area {
	padding: 16px 10px;
	height: calc(100vh - 122px); // 减去导航栏和筛选栏的高度
}

// 空状态样式
.empty-state {
	@include flex-center;
	@apply flex-col;
	padding: 80px 20px;
	gap: 16px;
}

// 加载更多提示样式
.load-more-tip {
	@include flex-center;
	padding: 20px 0;
}

.list-item {
	box-shadow: rgba(0, 0, 0, 0.1) 0px 2px 6px;
	border-right: 2px solid #3498db;
}

// 列表项样式
.item-icon {
	@include flex-center;
	@apply flex-shrink-0;
	width: 56px;
	height: 56px;
	border-radius: 12px;
	margin-right: 12px;
}

.item-content {
	@apply flex-1 min-w-0;
}

.item-meta {
	@apply flex items-center flex-row;
	gap: 12px;
}

.item-type {
	@apply bg-gray-100;
	font-size: 13px;
	color: #666;
	padding: 2px 8px;
	border-radius: 10px;
}

.item-time {
	font-size: 12px;
	color: #999;
}

// 左滑按钮样式
.swipe-actions {
	@apply flex flex-row items-center h-full;
}

.swipe-btn {
	@apply flex flex-col items-center justify-center;
	width: 80px;
	height: 100%;
	gap: 4px;
}

.swipe-btn--rename {
	background: #3498db;
}

.swipe-btn--delete {
	background: #ff4757;
}

// 弹窗样式
.popup-container {
	@apply flex flex-col;
	height: 100%;
	background: #fff;
	border-radius: 20px 20px 0 0;
}

.popup-header {
	@apply flex items-center justify-between;
	padding: 16px 20px;
	border-bottom: 1px solid #f0f0f0;
}

.header-actions {
	@apply flex flex-row items-center gap-2;
}

.close-icon {
	cursor: pointer;
}

.popup-content {
	@apply flex items-center justify-center flex-1;
	padding: 20px;
	overflow: auto;
}

.preview-text {
	width: 100%;
	line-height: 1.6;
	white-space: pre-wrap;
	word-break: break-word;
}

.preview-rich-text {
	width: 100%;
	line-height: 1.6;
	word-break: break-word;
}

// 重命名弹窗样式
.rename-popup-container {
	@apply flex flex-col;
	background: #fff;
	border-radius: 16px;
	padding: 20px;
	min-width: 280px;
}

.rename-popup-header {
	@apply flex items-center justify-center;
	margin-bottom: 20px;
}

.rename-popup-content {
	@apply flex flex-col;
	gap: 8px;
	margin-bottom: 20px;
}

.rename-input {
	width: 100%;
}

.char-count {
	@apply flex flex-row justify-end;
}

.rename-popup-footer {
	@apply flex flex-row items-center justify-end;
	gap: 12px;
}

// 笔记编辑器弹窗样式
.note-editor-popup-container {
	@apply flex flex-col;
	height: 100%;
	background: #fff;
	border-radius: 20px 20px 0 0;
}

.note-editor-header {
	@apply flex flex-col;
	padding: 16px 20px 12px;
	border-bottom: 1px solid #f0f0f0;
	gap: 12px;
}

.header-title-row {
	@apply flex flex-row items-center justify-between;
}

.note-title-input {
	font-size: 16px;
	font-weight: 600;
}

.note-editor-content {
	@apply flex-1;
	overflow-y: auto;
	padding: 10px 20px;
}

.note-editor-toolbar {
	position: sticky;
	bottom: 0;
	width: 100%;
}
</style>
